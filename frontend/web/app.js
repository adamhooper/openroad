// Generated by CoffeeScript 2.7.0
(function() {
  var AccidentFinder, AccidentsMarkerRenderer, AccidentsTableRenderer, CITIES, COLORS, ChartSeriesMaker, DEFAULT_MAX_DATE, DEFAULT_MAX_YEAR, DEFAULT_MIN_DATE, DEFAULT_MIN_YEAR, DataFetcher, ERROR_IN_DEGREES, ERROR_IN_M, M_PER_DEGREE, Manager, RANGE_IN_M, RouteFinder, RouteRenderer, State, TrendChartRenderer, URL, WORST_ACCIDENT_RADIUS, WorstLocationsRenderer, keepMapInStateBounds, originalClusterIconCreateCss, parseCsvData, selectText, showFusionTablesLayer, show_accidents_dialog, syncOriginDestinationMarkers,
    indexOf = [].indexOf;

  URL = "/%{city}";

  DEFAULT_MIN_YEAR = 2007;

  DEFAULT_MAX_YEAR = 2011;

  RANGE_IN_M = 30;

  ERROR_IN_M = 25;

  DEFAULT_MIN_DATE = '2007-01-01';

  DEFAULT_MAX_DATE = '2011-12-31';

  M_PER_DEGREE = 110574.27; // very rough

  ERROR_IN_DEGREES = ERROR_IN_M / M_PER_DEGREE;

  COLORS = {
    driving: '#0e3b5d',
    bicycling: '#a73438',
    both: '#f9f298'
  };

  CITIES = {
    vancouver: {
      latitude: 49.2505,
      longitude: -123.1119,
      zoom: 12,
      minYear: 2006,
      maxYear: 2010,
      fusionTableId: 3731863,
      bounds: new google.maps.LatLngBounds(new google.maps.LatLng(49.131859, -123.264954), new google.maps.LatLng(49.352188, -122.985718))
    },
    calgary: {
      latitude: 51.0451,
      longitude: -114.0569,
      zoom: 12,
      minYear: 1996,
      maxYear: 2011,
      fusionTableId: 3733170,
      bounds: new google.maps.LatLngBounds(new google.maps.LatLng(50.842941, -114.613968), new google.maps.LatLng(51.343868, -113.901817))
    },
    toronto: {
      latitude: 43.6517,
      longitude: -79.3827,
      zoom: 13,
      minYear: 1986,
      maxYear: 2010,
      fusionTableId: 3733171,
      bounds: new google.maps.LatLngBounds(new google.maps.LatLng(43.584740, -79.639297), new google.maps.LatLng(43.855419, -79.115623))
    },
    ottawa: {
      latitude: 45.4214,
      longitude: -75.6919,
      zoom: 13,
      minYear: 1999,
      maxYear: 2010,
      fusionTableId: 3734609,
      bounds: new google.maps.LatLngBounds(new google.maps.LatLng(44.962002, -76.355766), new google.maps.LatLng(45.536541, -75.246033))
    },
    montreal: {
      latitude: 45.5081,
      longitude: -73.5550,
      zoom: 13,
      minYear: 2006,
      maxYear: 2010,
      fusionTableId: 3731866,
      bounds: new google.maps.LatLngBounds(new google.maps.LatLng(45.413479, -73.976608), new google.maps.LatLng(45.704788, -73.476418))
    },
    halifax: {
      latitude: 44.6479,
      longitude: -63.5744,
      zoom: 13,
      minYear: 2007,
      maxYear: 2010,
      fusionTableId: 3733175,
      bounds: new google.maps.LatLngBounds(new google.maps.LatLng(44.434570, -64.237190), new google.maps.LatLng(45.276489, -62.160469))
    }
  };

  parseCsvData = function(data) {
    var headers, id, raw_rows;
    raw_rows = CSV.parse(data);
    headers = raw_rows[0];
    id = 1;
    return raw_rows.slice(1).map((row) => {
      var i, j, properties, ref;
      properties = {};
      for (i = j = 0, ref = headers.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
        properties[headers[i]] = row[i];
      }
      properties.Year = +properties.Time.slice(0, 4);
      properties.id = id;
      id++;
      return turf.point([+properties.Longitude, +properties.Latitude], properties);
    });
  };

  WORST_ACCIDENT_RADIUS = 7; // metres.

  // Two accidents can be double this apart and count as one location.

  // Monkey-patch MarkerClusterer to stay above DirectionsRenderer
  originalClusterIconCreateCss = ClusterIcon.prototype.createCss;

  ClusterIcon.prototype.createCss = function(pos) {
    var style;
    style = originalClusterIconCreateCss.call(this, pos);
    return `${style} z-index: 2000;`;
  };

  selectText = function(element) {
    var range, selection;
    if (document.body.createTextRange != null) {
      range = document.body.createTextRange();
      range.moveToElementText(element);
      return range.select();
    } else if (window.getSelection != null) {
      selection = window.getSelection();
      range = document.createRange();
      range.selectNodeContents(element);
      selection.removeAllRanges();
      return selection.addRange(range);
    }
  };

  State = class State {
    constructor(options = {}) {
      this.city = options.city || 'toronto';
      this.allAccidents = [];
      this.mode = 'bicycling';
      this.origin = options.origin;
      this.destination = options.destination;
      this.minYear = this._clampYear('min', options.minYear || DEFAULT_MIN_YEAR);
      this.maxYear = this._clampYear('max', options.maxYear || DEFAULT_MAX_YEAR);
      this.routes = {}; // keyed by 'bicycling' and 'driving'
      this.accidents = {}; // keyed by 'bicycling' and 'driving'
      this.listeners = {};
      this.frozen = {};
      this.entireCity = false;
      this.selectingOriginOrDestination = void 0;
    }

    // @routes is always set before @accidents
    onChange(key, callback) {
      var base;
      (base = this.listeners)[key] || (base[key] = []);
      return this.listeners[key].push(callback);
    }

    // Delay running onChange callbacks on this key until thaw()
    freeze(key) {
      if (this.frozen[key] == null) {
        return this.frozen[key] = true;
      }
    }

    // Allow onChange callbacks to run on this key. If the property changed
    // after freeze() was called, run them now.
    thaw(key) {
      var arg1;
      if (this.frozen[key] == null) {
        return;
      }
      if (this.frozen[key] === true) {
        return delete this.frozen[key];
      } else {
        arg1 = this.frozen[key][0];
        delete this.frozen[key];
        return this._changed(key, arg1);
      }
    }

    _changed(key, arg1 = void 0) {
      var callback, callbacks, j, len, results1;
      if (this.frozen[key] != null) {
        return this.frozen[key] = [arg1];
      } else {
        callbacks = this.listeners[key] || [];
        results1 = [];
        for (j = 0, len = callbacks.length; j < len; j++) {
          callback = callbacks[j];
          results1.push(callback(arg1));
        }
        return results1;
      }
    }

    setAllAccidents(data) {
      this.allAccidents = data;
      return this._changed('allAccidents', data);
    }

    setMode(mode) {
      if (this.mode === mode) {
        return;
      }
      this.mode = mode;
      this._changed('mode', this.mode);
      return this.setEntireCity(false);
    }

    setOrigin(latlng) {
      if (latlng === this.origin) {
        return;
      }
      this.clearAccidents();
      this.clearRoutes();
      this.setEntireCity(false);
      this.origin = latlng;
      return this._changed('origin', this.origin);
    }

    setDestination(latlng) {
      if (latlng === this.destination) {
        return;
      }
      this.clearAccidents();
      this.clearRoutes();
      this.setEntireCity(false);
      this.destination = latlng;
      return this._changed('destination', this.destination);
    }

    _clampYear(minOrMax, year) {
      var clamp, property;
      property = `${minOrMax}Year`;
      clamp = CITIES[this.city][property];
      if (!year) {
        return clamp;
      }
      if (minOrMax === 'min' && year < clamp) {
        return clamp;
      }
      if (minOrMax === 'max' && year > clamp) {
        return clamp;
      }
      return year;
    }

    setMinYear(year) {
      var clampedYear;
      clampedYear = this._clampYear('min', year);
      if (clampedYear !== this.minYear) {
        this.clearAccidents();
        this.minYear = clampedYear;
        return this._changed('minYear', this.minYear);
      }
    }

    setMaxYear(year) {
      var clampedYear;
      clampedYear = this._clampYear('max', year);
      if (clampedYear !== this.maxYear) {
        this.clearAccidents();
        this.maxYear = clampedYear;
        return this._changed('maxYear', this.maxYear);
      }
    }

    setRoute(key, directions) {
      if (this.accidents[key] != null) {
        delete this.accidents[key];
        this._changed('accidents', this.accidents);
      }
      this.routes[key] = directions;
      return this._changed('routes', this.routes);
    }

    clearRoutes() {
      this.routes = {};
      return this._changed('routes', this.routes);
    }

    setAccidents(key, accidents) {
      this.accidents[key] = accidents;
      return this._changed('accidents', this.accidents);
    }

    clearAccidents() {
      this.accidents = {};
      return this._changed('accidents', this.accidents);
    }

    setEntireCity(entireCity) {
      if (entireCity === this.entireCity) {
        return;
      }
      this.entireCity = entireCity;
      return this._changed('entireCity', this.entireCity);
    }

    setSelectingOriginOrDestination(selectingOriginOrDestination) {
      if (selectingOriginOrDestination === this.selectingOriginOrDestination) {
        return;
      }
      if ((selectingOriginOrDestination == null) && this.selectingOriginOrDestination === 'origin' && (this.origin == null)) {
        return;
      }
      if ((selectingOriginOrDestination == null) && this.selectingOriginOrDestination === 'destination' && (this.destination == null)) {
        return;
      }
      this.selectingOriginOrDestination = selectingOriginOrDestination;
      return this._changed('selectingOriginOrDestination', this.selectingOriginOrDestination);
    }

  };

  window.State = State;

  DataFetcher = class DataFetcher {
    constructor(state1) {
      this.state = state1;
      // TODO fix race condition
      fetch(`/data/${this.state.city}.csv`).then((response) => {
        return response.text();
      }).then((data) => {
        return this.state.setAllAccidents(parseCsvData(data));
      });
    }

  };

  RouteFinder = class RouteFinder {
    constructor(state1) {
      this.state = state1;
      this.state.onChange('origin', () => {
        return this.refresh();
      });
      this.state.onChange('destination', () => {
        return this.refresh();
      });
      this.state.onChange('mode', () => {
        return this.refresh();
      });
      this._activeRequestIds = {};
      this._activeRequestIds[google.maps.TravelMode.BICYCLING] = 0;
      this._activeRequestIds[google.maps.TravelMode.DRIVING] = 0;
    }

    _getCityBounds() {
      return CITIES[this.state.city].bounds;
    }

    _modeToGoogleModes(mode) {
      return {
        driving: [google.maps.TravelMode.DRIVING],
        bicycling: [google.maps.TravelMode.BICYCLING],
        both: [google.maps.TravelMode.BICYCLING, google.maps.TravelMode.DRIVING]
      }[mode];
    }

    _googleModeToMode(mode) {
      if (mode === google.maps.TravelMode.DRIVING) {
        return 'driving';
      } else {
        return 'bicycling';
      }
    }

    _getDirectionsRequestForMode(mode) {
      var googleMode, j, len, ref, results1;
      ref = _modeToGoogleModes(mode);
      results1 = [];
      for (j = 0, len = ref.length; j < len; j++) {
        googleMode = ref[j];
        results1.push(this._getDirectionsRequestForGoogleMode(googleMode));
      }
      return results1;
    }

    _getDirectionsRequestForGoogleMode(googleMode) {
      return {
        origin: this.state.origin,
        destination: this.state.destination,
        travelMode: googleMode,
        provideRouteAlternatives: false,
        unitSystem: google.maps.UnitSystem.METRIC,
        region: 'ca'
      };
    }

    _getDirectionsService() {
      return this.directionsService || (this.directionsService = new google.maps.DirectionsService());
    }

    refresh() {
      var googleMode, j, len, ref, results1;
      if ((this.state.origin == null) || (this.state.destination == null)) {
        this.state.clearRoutes();
        return;
      }
      ref = this._modeToGoogleModes(this.state.mode);
      results1 = [];
      for (j = 0, len = ref.length; j < len; j++) {
        googleMode = ref[j];
        results1.push(this._refreshGoogleModeRoute(googleMode));
      }
      return results1;
    }

    _refreshGoogleModeRoute(googleMode) {
      var mode, request, requestId, service;
      mode = this._googleModeToMode(googleMode);
      if (this.state.routes[mode]) {
        return;
      }
      service = this._getDirectionsService();
      request = this._getDirectionsRequestForGoogleMode(googleMode);
      requestId = (this._activeRequestIds[googleMode] += 1);
      return service.route(request, (result, status) => {
        if (this._activeRequestIds[googleMode] !== requestId) {
          return;
        }
        if (status !== google.maps.DirectionsStatus.OK) { // FIXME handle error
          return;
        }
        return this.state.setRoute(mode, result);
      });
    }

  };

  RouteRenderer = class RouteRenderer {
    constructor(state1, map1) {
      var j, len, mode, ref;
      this.state = state1;
      this.map = map1;
      this.renderers = {};
      this._blockingStateChanges = {};
      ref = ['bicycling', 'driving'];
      for (j = 0, len = ref.length; j < len; j++) {
        mode = ref[j];
        this._blockingStateChanges[mode] = false;
        this.renderers[mode] = this._createDirectionsRendererForMode(mode, map);
      }
      this.state.onChange('routes', () => {
        return this.refresh();
      });
      this.state.onChange('mode', () => {
        return this.refresh();
      });
      this.state.onChange('entireCity', () => {
        return this.refresh();
      });
    }

    refresh() {
      var j, len, mode, ref, results1, route;
      ref = ['bicycling', 'driving'];
      results1 = [];
      for (j = 0, len = ref.length; j < len; j++) {
        mode = ref[j];
        if (this._blockingStateChanges[mode]) {
          continue;
        }
        route = this.state.routes[mode];
        if (route && (this.state.mode === 'both' || mode === this.state.mode)) {
          this._blockingStateChanges[mode] = true;
          this.renderers[mode].setDirections(route);
          this.renderers[mode].setMap(!this.state.entireCity && this.map || null);
          results1.push(this._blockingStateChanges[mode] = false);
        } else {
          results1.push(this.renderers[mode].setMap(null));
        }
      }
      return results1;
    }

    _createDirectionsRendererForMode(mode) {
      var color, renderer;
      color = COLORS[mode];
      renderer = new google.maps.DirectionsRenderer({
        draggable: true,
        polylineOptions: {
          strokeColor: color
        },
        preserveViewport: true,
        suppressInfoWindows: true,
        suppressMarkers: true,
        suppressBicyclingLayer: true
      });
      google.maps.event.addListener(renderer, 'directions_changed', () => {
        if (this._blockingStateChanges[mode]) {
          return;
        }
        this._blockingStateChanges[mode] = true;
        this.state.setRoute(mode, renderer.getDirections());
        return this._blockingStateChanges[mode] = false;
      });
      return renderer;
    }

  };

  AccidentFinder = class AccidentFinder {
    constructor(state1) {
      this.state = state1;
      this._requests = {}; // mode => ajax
      this.state.onChange('allAccidents', () => {
        return this.refresh();
      });
      this.state.onChange('routes', () => {
        return this.refresh();
      });
      this.state.onChange('minYear', () => {
        return this.refresh();
      });
      this.state.onChange('maxYear', () => {
        return this.refresh();
      });
    }

    refresh() {
      var j, len, mode, ref, results1;
      ref = this.state.mode !== 'both' && [this.state.mode] || ['bicycling', 'driving'];
      results1 = [];
      for (j = 0, len = ref.length; j < len; j++) {
        mode = ref[j];
        results1.push(this._refreshAccidents(mode));
      }
      return results1;
    }

    _refreshAccidents(mode) {
      var data, maxX, maxY, minX, minY, options, polyline, route;
      route = this.state.routes[mode];
      if (route == null) {
        return;
      }
      polyline = turf.lineString(route.routes[0].overview_path.map(function({lat, lng}) {
        return [lng(), lat()];
      }));
      //turf.simplify(polyline, { tolerance: ERROR_IN_DEGREES, highQuality: true, mutate: true })
      [minX, minY, maxX, maxY] = turf.bbox(polyline);
      options = {
        units: 'metres'
      };
      data = [];
      this.state.allAccidents.forEach((accident) => {
        var snapped;
        if (accident.properties.Year < this.state.minYear) {
          return;
        }
        if (accident.properties.Year > this.state.maxYear) {
          return;
        }
        snapped = turf.nearestPointOnLine(polyline, accident, options);
        if (snapped.properties.dist > RANGE_IN_M) {
          return;
        }
        return data.push({
          ...accident,
          properties: {
            ...accident.properties,
            distance_along_path: snapped.properties.location
          }
        });
      });
      return this.state.setAccidents(mode, data);
    }

  };

  ChartSeriesMaker = class ChartSeriesMaker {
    constructor() {
      this.data = {};
    }

    add(year) {
      var base, y;
      y = year.toString();
      (base = this.data)[y] || (base[y] = 0);
      return this.data[y] += 1;
    }

    getSeries() {
      var k, ref, results1, v;
      ref = this.data;
      results1 = [];
      for (k in ref) {
        v = ref[k];
        results1.push([+k, v]);
      }
      return results1;
    }

  };

  show_accidents_dialog = function(state1, onlyIds = void 0) {
    var $div, $p, $tr, accidents, id, j, len, render_table, theseAre;
    this.state = state1;
    render_table = function() {
      var $table, $tbody, $tds, $th, $theadTr, $tr, accident, accidents, heading, headings, i, j, key, keys, l, len, len1, len2, m, mode, modeAccidents, ref, ref1, ref2, text, textNode, trClass, value;
      accidents = [];
      ref = state.accidents;
      for (mode in ref) {
        modeAccidents = ref[mode];
        if (!(mode === state.mode || state.mode === 'both')) {
          continue;
        }
        accidents = accidents.concat(modeAccidents);
      }
      if (!(accidents.length > 0)) {
        return;
      }
      $table = $('<table><thead><tr><th class="id">ID</th><th class="distance_along_path">Odometer</th></tr></thead><tbody></tbody></table>');
      headings = [];
      ref1 = accidents[0].properties;
      for (heading in ref1) {
        value = ref1[heading];
        if (heading === 'id') {
          continue;
        }
        if (heading === 'distance_along_path') {
          continue;
        }
        if (heading === 'Time') {
          continue;
        }
        // We can't give Google-provided geocoded data (all cities but Toronto)
        if (state.city !== 'Toronto') {
          if (heading === 'Latitude') {
            continue;
          }
          if (heading === 'Longitude') {
            continue;
          }
        }
        headings.push(heading);
      }
      headings.sort();
      headings.unshift('Time');
      keys = (function() {
        var j, len, results1;
        results1 = [];
        for (j = 0, len = headings.length; j < len; j++) {
          heading = headings[j];
          results1.push(heading.toLowerCase().replace(/\s/g, '-'));
        }
        return results1;
      })();
      keys.unshift('distance_along_path');
      keys.unshift('id');
      $theadTr = $table.find('thead').children();
      for (i = j = 0, len = headings.length; j < len; i = ++j) {
        heading = headings[i];
        $th = $('<th></th>');
        $th.attr('class', keys[i + 2]);
        $th.text(heading);
        $theadTr.append($th);
      }
      $tbody = $table.find('tbody');
      trClass = 'odd';
      ref2 = state.accidents;
      for (mode in ref2) {
        modeAccidents = ref2[mode];
        if (!(mode === state.mode || state.mode === 'both')) {
          continue;
        }
        for (l = 0, len1 = modeAccidents.length; l < len1; l++) {
          accident = modeAccidents[l];
          $tr = $(`<tr class=\"${mode}\">` + ((function() {
            var len2, m, results1;
            results1 = [];
            for (m = 0, len2 = keys.length; m < len2; m++) {
              key = keys[m];
              results1.push('<td></td>');
            }
            return results1;
          })()).join('') + '</tr>');
          $tr.attr('class', trClass);
          $tr.attr('class', `accident-${accident.properties.id}`);
          $tr.attr('id', `accident-${mode}-${accident.properties.id}`);
          $tds = $tr.children();
          if (trClass === 'odd') {
            trClass = 'even';
          } else {
            trClass = 'odd';
          }
          for (i = m = 0, len2 = keys.length; m < len2; i = ++m) {
            key = keys[i];
            heading = headings[i - 2];
            $tds[i].className = key;
            text = accident.properties[heading] || accident.properties[key];
            if (key === 'distance_along_path') {
              text = `${text}m (${mode})`;
            }
            textNode = document.createTextNode(text || '');
            $tds[i].appendChild(textNode);
          }
          $tbody.append($tr);
        }
      }
      $table.on('dblclick', function(e) {
        return selectText($table[0]);
      });
      return $table;
    };
    $div = $('<div id="data-dialog"><p class="blurb">Data geeks, this is for you. Here is our raw data: every detail we know about the accidents you found. The more ambitious among you may see and download <a target="_blank" href="https://github.com/adamhooper/openroad/tree/master/data">our entire datasets</a>, too.</p><div id="data-dialog-inner"></div></div>');
    $div.find('#data-dialog-inner').append(render_table());
    if ((onlyIds != null) && onlyIds.length > 0) {
      $div.find('table').addClass('with-highlights');
      for (j = 0, len = onlyIds.length; j < len; j++) {
        id = onlyIds[j];
        $tr = $div.find(`tr.accident-${id}`);
        $tr.addClass('highlighted');
        $tr.show();
      }
      theseAre = onlyIds.length === 1 && 'This is' || 'These are';
      accidents = onlyIds.length === 1 && 'accident' || 'accidents';
      $p = $(`<p>${theseAre} just the ${accidents} you clicked. You may also see <a href=\"#\">all accidents along your route</a>.</p>`);
      $div.append($p);
      $p.find('a').on('click', function(e) {
        e.preventDefault();
        $div.find('table').removeClass('with-highlights');
        return $p.remove();
      });
    }
    return $div.dialog({
      buttons: [
        {
          text: 'Close',
          click: function() {
            $(this).dialog('destroy');
            return $div.remove();
          }
        }
      ],
      dialogClass: 'dialog-accident-data',
      draggable: false,
      modal: true,
      resizable: false,
      position: 'center',
      title: 'Detailed accident reports',
      width: $(window).width() * 0.9,
      height: $(window).height() * 0.9
    });
  };

  AccidentsTableRenderer = class AccidentsTableRenderer {
    constructor(state1, link) {
      this.state = state1;
      $(link).on('click', (e) => {
        e.preventDefault();
        return show_accidents_dialog(this.state);
      });
    }

  };

  TrendChartRenderer = class TrendChartRenderer {
    constructor(state1, link) {
      this.state = state1;
      $(link).on('click', (e) => {
        var $div;
        e.preventDefault();
        $div = this.renderChartContainer();
        $div.dialog({
          buttons: [
            {
              text: 'Close',
              click: function() {
                $(this).dialog('destroy');
                return $div.remove();
              }
            }
          ],
          dialogClass: 'dialog-accidents-by-year',
          draggable: false,
          modal: true,
          resizable: false,
          position: 'center',
          title: 'Accidents per year along your route',
          width: $(window).width() * 0.8,
          height: $(window).height() * 0.8
        });
        return window.setTimeout(() => {
          // Need to be positioned first
          return this.renderChartInChartContainer($div);
        }, 50);
      });
    }

    renderChartContainer() {
      return $('<div id="chart-dialog"><p class="blurb">Is there a trend along your route? Many events can correlate: construction, a new bike lane, more attentive police or dumb luck. Here we show, for each year, the number of reported collisions between car and bike.</p><div id="chart-dialog-inner"></div></div>');
    }

    _modeToColor(mode) {
      return COLORS[mode];
    }

    renderChartInChartContainer($div) {
      var accident, accidentTickInterval, accidents, color, innerId, j, l, len, len1, maxAccidents, mode, modeSeries, plotSeries, plotSeriesOptions, ref, series, seriesEntry, seriesMaker, tuple, yearTickInterval;
      series = {};
      ref = this.state.accidents;
      for (mode in ref) {
        accidents = ref[mode];
        if (!(mode === this.state.mode || this.state.mode === 'both')) {
          continue;
        }
        seriesMaker = new ChartSeriesMaker();
        for (j = 0, len = accidents.length; j < len; j++) {
          accident = accidents[j];
          seriesMaker.add(accident.properties.Time.split(/-/)[0]);
        }
        series[mode] = seriesMaker.getSeries();
      }
      maxAccidents = 1;
      for (mode in series) {
        modeSeries = series[mode];
        for (l = 0, len1 = modeSeries.length; l < len1; l++) {
          tuple = modeSeries[l];
          if (tuple[1] > maxAccidents) {
            maxAccidents = tuple[1];
          }
        }
      }
      plotSeries = [];
      plotSeriesOptions = [];
      for (mode in series) {
        seriesEntry = series[mode];
        color = this._modeToColor(mode);
        plotSeries.push(seriesEntry);
        plotSeriesOptions.push({
          color: color,
          label: mode.substring(0, 1).toUpperCase() + mode.substring(1)
        });
      }
      innerId = $div.children('div').attr('id');
      if ($.browser.msie && $.browser.version < '7') {
        $(`#${innerId}`).css({
          position: 'relative',
          height: 200
        });
      }
      // No more than 10 ticks horizontally
      yearTickInterval = Math.floor((this.state.maxYear - this.state.minYear + 1) / 10) + 1;
      // No more than 10 ticks vertically
      accidentTickInterval = Math.floor(maxAccidents / 10) + 1;
      return $.jqplot(innerId, plotSeries, {
        highlighter: {
          show: true,
          sizeAdjust: 12
        },
        cursor: {
          show: false
        },
        axes: {
          xaxis: {
            min: this.state.minYear - 1,
            max: this.state.maxYear + 1,
            tickInterval: yearTickInterval,
            showTickMarks: false,
            tickOptions: {
              showGridline: false,
              showMark: false
            }
          },
          yaxis: {
            min: 0,
            tickInterval: accidentTickInterval,
            showTickMarks: false,
            tickOptions: {
              showMark: false
            }
          }
        },
        grid: {
          gridLineColor: 'white',
          background: '#f9f298',
          shadow: false,
          borderWidth: 0
        },
        seriesDefaults: {
          shadow: false,
          markerOptions: {
            size: 12,
            shadow: false
          }
        },
        series: plotSeriesOptions,
        legend: {
          show: this.state.mode === 'both',
          location: 'sw'
        }
      });
    }

  };

  AccidentsMarkerRenderer = class AccidentsMarkerRenderer {
    constructor(state1, map1) {
      this.state = state1;
      this.map = map1;
      this.markerArrays = {};
      this.markers = [];
      this.clusterer = this._createClusterer();
      this.state.onChange('accidents', () => {
        return this.refresh();
      });
      this.state.onChange('mode', () => {
        return this.refresh();
      });
      this.state.onChange('entireCity', () => {
        return this.refresh();
      });
      google.maps.event.addListener(this.clusterer, 'click', (cluster) => {
        var marker;
        return show_accidents_dialog(this.state, (function() {
          var j, len, ref, results1;
          ref = cluster.getMarkers();
          results1 = [];
          for (j = 0, len = ref.length; j < len; j++) {
            marker = ref[j];
            results1.push(marker.accidentUniqueKey);
          }
          return results1;
        })());
      });
    }

    _createClusterer() {
      var calculateMarkerStyleIndex, clusterUrlRoot, iconStyles;
      iconStyles = [];
      clusterUrlRoot = `${window.location.protocol}//${window.location.host}${window.location.pathname.replace(/[^\/]*$/, '')}/icons`;
      calculateMarkerStyleIndex = function(markers, nIconStyles) {
        var text;
        text = `${markers.length}`;
        return {
          text: text,
          index: 1
        };
      };
      iconStyles = [
        {
          width: 18,
          height: 18,
          textSize: 10,
          textColor: '#000000',
          url: `${clusterUrlRoot}/marker-accident.png`
        }
      ];
      return new MarkerClusterer(this.map, [], {
        averageCenter: true,
        gridSize: 13,
        styles: iconStyles,
        calculator: calculateMarkerStyleIndex,
        minimumClusterSize: 1,
        printable: true,
        zoomOnClick: false
      });
    }

    _createMarkerArray(mode, accidents) {
      var accident, arr, j, latLng, latitude, len, longitude, marker;
      arr = [];
      for (j = 0, len = accidents.length; j < len; j++) {
        accident = accidents[j];
        latitude = accident.properties.Latitude;
        longitude = accident.properties.Longitude;
        latLng = new google.maps.LatLng(latitude, longitude);
        marker = new google.maps.Marker({
          position: latLng,
          flat: true
        });
        marker.accidentUniqueKey = `${accident.properties.id}`;
        arr.push(marker);
      }
      return arr;
    }

    _refreshMarkerModes() {
      var _, accidentKeyToMode, j, key, len, marker, markers, mode, ref, ref1, results1;
      // for each marker, sets marker.accidentPath to 'bicycling', 'driving' or 'both'
      accidentKeyToMode = {};
      ref = this.markerArrays;
      for (mode in ref) {
        markers = ref[mode];
        for (j = 0, len = markers.length; j < len; j++) {
          marker = markers[j];
          key = marker.accidentUniqueKey;
          if ((accidentKeyToMode[key] != null) && accidentKeyToMode[key] !== mode) {
            accidentKeyToMode[key] = 'both';
          } else {
            accidentKeyToMode[key] = mode;
          }
        }
      }
      ref1 = this.markerArrays;
      results1 = [];
      for (_ in ref1) {
        markers = ref1[_];
        results1.push((function() {
          var l, len1, results2;
          results2 = [];
          for (l = 0, len1 = markers.length; l < len1; l++) {
            marker = markers[l];
            key = marker.accidentUniqueKey;
            results2.push(marker.accidentPath = accidentKeyToMode[key]);
          }
          return results2;
        })());
      }
      return results1;
    }

    refresh() {
      var j, l, len, len1, len2, m, marker, markerKeys, mode, ref, ref1, ref2;
      this.clusterer.removeMarkers(this.markers, true);
      this.markers = [];
      if (this.state.entireCity) {
        this.markerArrays = {};
        this.clusterer.repaint();
        return;
      }
      ref = ['bicycling', 'driving'];
      for (j = 0, len = ref.length; j < len; j++) {
        mode = ref[j];
        if ((this.state.accidents[mode] != null) && (this.state.mode === 'both' || this.state.mode === mode)) {
          if (this.markerArrays[mode] == null) {
            // And we aren't rendering them
            this.markerArrays[mode] = this._createMarkerArray(mode, this.state.accidents[mode]);
          }
        } else {
          // There's a lack of accidents to render
          if (this.markerArrays[mode] != null) {
            // But we're rendering them
            delete this.markerArrays[mode];
          }
        }
      }
      this._refreshMarkerModes();
      markerKeys = {};
      ref1 = ['bicycling', 'driving'];
      for (l = 0, len1 = ref1.length; l < len1; l++) {
        mode = ref1[l];
        if (this.markerArrays[mode] == null) {
          continue;
        }
        ref2 = this.markerArrays[mode];
        for (m = 0, len2 = ref2.length; m < len2; m++) {
          marker = ref2[m];
          if (markerKeys[marker.accidentUniqueKey] == null) {
            markerKeys[marker.accidentUniqueKey] = true;
            this.markers.push(marker);
          }
        }
      }
      this.clusterer.addMarkers(this.markers, true);
      return this.clusterer.repaint();
    }

  };

  WorstLocationsRenderer = class WorstLocationsRenderer {
    constructor(state1, div, map1) {
      this.state = state1;
      this.div = div;
      this.map = map1;
      this.topGroupsByMode = {};
      this.maxLocations = 3;
      this.markers = [];
      this.state.onChange('accidents', () => {
        return this.refresh();
      });
      this.state.onChange('mode', () => {
        return this.refresh();
      });
      this.state.onChange('entireCity', () => {
        return this.refresh();
      });
    }

    _accidentsToTopGroups(accidents) {
      var a, accident, d, distance_along_path, i, j, l, len, len1, len2, m, n, o, objs, ref, ref1, ref2, ref3, ref4, results, sorted, topGroup;
      objs = [];
      results = [];
// We define a "spot" as a [x-7..x+7] stretch along the "distance_along_path" axis.

      // 1. Calculate all those stretches, in a sparse array of arrays, indexed by meter
      for (j = 0, len = accidents.length; j < len; j++) {
        accident = accidents[j];
        distance_along_path = Math.round(accident.properties.distance_along_path);
        for (d = l = ref = distance_along_path - WORST_ACCIDENT_RADIUS, ref1 = distance_along_path + WORST_ACCIDENT_RADIUS; (ref <= ref1 ? l <= ref1 : l >= ref1); d = ref <= ref1 ? ++l : --l) {
          if (d < 0) {
            continue;
          }
          objs[d] || (objs[d] = []);
          objs[d].push(accident);
        }
      }
      // 2. Calculate results
      // Select the largest slot, and repeat as needed
      sorted = objs.slice();
      while (results.length < this.maxLocations) {
        sorted.sort(function(a, b) {
          return b.length - a.length;
        });
        if (sorted.length === 0 || sorted[0].length === 0) {
          break;
        }
        topGroup = sorted[0].slice();
        results.push(topGroup);
// Remove these accidents from our "worst accident spot" contendors
        for (m = 0, len1 = topGroup.length; m < len1; m++) {
          accident = topGroup[m];
          distance_along_path = Math.round(accident.properties.distance_along_path);
          for (d = n = ref2 = distance_along_path - WORST_ACCIDENT_RADIUS, ref3 = distance_along_path + WORST_ACCIDENT_RADIUS; (ref2 <= ref3 ? n <= ref3 : n >= ref3); d = ref2 <= ref3 ? ++n : --n) {
            if (d < 0 || d >= objs.length) {
              continue;
            }
            ref4 = objs[d];
            for (i = o = 0, len2 = ref4.length; o < len2; i = ++o) {
              a = ref4[i];
              if (a.distance_along_path === accident.distance_along_path) {
                // We don't need to check for equality: if one accident at this
                // distance matches, they'll all match and they'll all be removed
                objs[d].splice(i, 1);
                break;
              }
            }
          }
        }
      }
      return results;
    }

    _getActiveModes() {
      if (this.state.mode === 'both') {
        return ['bicycling', 'driving'];
      } else {
        return [this.state.mode];
      }
    }

    _getTopSpots() {
      var accident, idToSpot, j, l, len, len1, len2, len3, len4, m, mode, n, o, ref, ref1, topGroup, topSpot, topSpots;
      idToSpot = {};
      topSpots = [];
      ref = this._getActiveModes();
      for (j = 0, len = ref.length; j < len; j++) {
        mode = ref[j];
        if (this.topGroupsByMode[mode] == null) {
          continue;
        }
        ref1 = this.topGroupsByMode[mode];
        for (l = 0, len1 = ref1.length; l < len1; l++) {
          topGroup = ref1[l];
          // If two groups (one per mode) contain the same accident, merge them.
          topSpot = void 0;
// Search for the duplicates
          for (m = 0, len2 = topGroup.length; m < len2; m++) {
            accident = topGroup[m];
            if (idToSpot[accident.properties.id] != null) {
              topSpot = idToSpot[accident.properties.id];
              topSpot.mode = 'both';
              break;
            }
          }
          if (topSpot == null) {
            topSpot = {
              mode: mode,
              accidents: []
            };
            topSpots.push(topSpot);
          }
// Merge/copy into the array
          for (n = 0, len3 = topGroup.length; n < len3; n++) {
            accident = topGroup[n];
            if (idToSpot[accident.properties.id] == null) {
              idToSpot[accident.properties.id] = topSpot;
              topSpot.accidents.push(accident);
            }
          }
        }
      }
      topSpots.sort(function(a, b) {
        return b.accidents.length - a.accidents.length;
      });
      topSpots = topSpots.slice(0, 3);
      for (o = 0, len4 = topSpots.length; o < len4; o++) {
        topSpot = topSpots[o];
        this._fillLocation(topSpot);
      }
      return topSpots;
    }

    _fillLocation(topSpot) {
      var accident, j, latitude, len, longitude, ref, sumLatitude, sumLongitude;
      sumLatitude = 0;
      sumLongitude = 0;
      ref = topSpot.accidents;
      for (j = 0, len = ref.length; j < len; j++) {
        accident = ref[j];
        [longitude, latitude] = accident.geometry.coordinates;
        sumLatitude += latitude;
        sumLongitude += longitude;
      }
      topSpot.Latitude = sumLatitude / topSpot.accidents.length;
      return topSpot.Longitude = sumLongitude / topSpot.accidents.length;
    }

    _getHeadingString(topSpots) {
      var locations, routes;
      locations = topSpots.length === 1 && 'location' || 'locations';
      routes = (this.topGroupsByMode.bicycling != null) && (this.topGroupsByMode.driving != null) && 'routes' || 'route';
      return `Most accident-prone ${locations} along your ${routes}`;
    }

    _getTopSpotString(topSpot) {
      var accidents;
      accidents = topSpot.accidents.length === 1 && 'accident' || 'accidents';
      if (topSpot.mode === 'both') {
        return `${topSpot.accidents.length} ${accidents} along your driving and bicycling routes`;
      } else {
        return `${topSpot.accidents.length} ${accidents} along your ${topSpot.mode} route`;
      }
    }

    _getGeocoder() {
      return this.geocoder || (this.geocoder = new google.maps.Geocoder());
    }

    _geocoderResultsToAddress(results) {
      var j, l, len, len1, ref, result, type;
      ref = ['intersection', 'bus_station', 'transit_station', 'neighborhood'];
      for (j = 0, len = ref.length; j < len; j++) {
        type = ref[j];
        for (l = 0, len1 = results.length; l < len1; l++) {
          result = results[l];
          if (indexOf.call(result.types, type) >= 0) {
            return result.formatted_address.split(/,/)[0];
          }
        }
      }
      return results[0].formatted_address.split(/,/)[0];
    }

    _renderTopSpot(topSpot) {
      var $html;
      $html = $('<li><div class="image-container"><img src="" alt="" /></div><div class="address"></div><div class="count"></div></li>');
      $html.find('.address').text(`${topSpot.Latitude},${topSpot.Longitude}`);
      $html.find('.count').text(this._getTopSpotString(topSpot));
      this._getGeocoder().geocode({
        latLng: new google.maps.LatLng(topSpot.Latitude, topSpot.Longitude)
      }, (results, status) => {
        var address;
        if (status === google.maps.GeocoderStatus.OK) {
          address = this._geocoderResultsToAddress(results);
          return $html.find('.address').text(address);
        }
      });
      // Wait for the image to be drawn so we know its height
      window.setTimeout(function() {
        var $img, url;
        $img = $html.find('img');
        url = `https://maps.googleapis.com/maps/api/streetview?size=${$img.width()}x${Math.round($img.width() * 9 / 16)}&location=${topSpot.Latitude},${topSpot.Longitude}&key=AIzaSyDWrbWJ46ET44B2Z0UFdqsT3DbsZXKXuqU`;
        return $img.attr('src', url);
      }, 50);
      return $html;
    }

    _fillDiv(topSpots) {
      var $div, $h2, $li, $ul, h2String, i, j, len, topSpot;
      $div = $(this.div);
      $div.empty();
      if (!topSpots.length) {
        $div.hide();
        return;
      }
      h2String = this._getHeadingString(topSpots);
      $h2 = $('<h2></h2>');
      $h2.text(h2String);
      $div.append($h2);
      $ul = $('<ul></ul>');
      for (i = j = 0, len = topSpots.length; j < len; i = ++j) {
        topSpot = topSpots[i];
        $li = this._renderTopSpot(topSpot, i);
        $li.addClass(`top-spot-${i}`);
        $ul.append($li);
      }
      $div.append($ul);
      return $div.show();
    }

    _topSpotsToMarkers(topSpots) {
      var j, len, marker, markers, max, topSpot;
      markers = [];
      if (!topSpots.length) {
        return [];
      }
      max = topSpots[0].accidents.length;
      for (j = 0, len = topSpots.length; j < len; j++) {
        topSpot = topSpots[j];
        if (topSpot.accidents.length !== max) {
          break;
        }
        marker = new google.maps.Marker({
          clickable: false,
          flat: true,
          optimized: false,
          position: new google.maps.LatLng(topSpot.Latitude, topSpot.Longitude),
          icon: new google.maps.MarkerImage('./icons/marker-top-spot.png', new google.maps.Size(37, 28), void 0, new google.maps.Point(19, 14)),
          title: 'Accident-prone location'
        });
        markers.push(marker);
      }
      return markers;
    }

    refresh() {
      var changed, j, l, len, len1, marker, mode, ref, ref1, results1, topSpots;
      // Assume accidents array only changes from (set 1) -> (undefined) -> (set 2)
      // This optimizes a common case, (set 1) -> (set 1)
      changed = false;
      ref = ['bicycling', 'driving'];
      for (j = 0, len = ref.length; j < len; j++) {
        mode = ref[j];
        if ((this.state.accidents[mode] != null) && (this.state.mode === 'both' || this.state.mode === mode) && !this.state.entireCity) {
          if (this.topGroupsByMode[mode] == null) {
            // And we aren't rendering them
            this.topGroupsByMode[mode] = this._accidentsToTopGroups(this.state.accidents[mode]);
            changed = true;
          }
        } else {
          // There's a lack of accidents to render
          if (this.topGroupsByMode[mode] != null) {
            // But we're rendering them
            delete this.topGroupsByMode[mode];
            changed = true;
          }
        }
      }
      if (changed) {
        (function() {
          var l, len1, ref1, results1;
          ref1 = this.markers;
          results1 = [];
          for (l = 0, len1 = ref1.length; l < len1; l++) {
            marker = ref1[l];
            results1.push(marker.setMap(null));
          }
          return results1;
        }).call(this);
        topSpots = this._getTopSpots();
        this._fillDiv(topSpots);
        this.markers = this._topSpotsToMarkers(topSpots);
        ref1 = this.markers;
        results1 = [];
        for (l = 0, len1 = ref1.length; l < len1; l++) {
          marker = ref1[l];
          results1.push(marker.setMap(this.map));
        }
        return results1;
      }
    }

  };

  keepMapInStateBounds = function(map, state) {
    var extendMapBoundsToFitPosition, fitMapToCityBounds, j, key, len, ref, results1;
    fitMapToCityBounds = function(city) {
      var cityData, latLng;
      cityData = CITIES[city];
      latLng = new google.maps.LatLng(cityData.latitude, cityData.longitude);
      map.setCenter(latLng);
      return map.setZoom(cityData.zoom);
    };
    fitMapToCityBounds(state.city);
    extendMapBoundsToFitPosition = function(latLng) {
      var bounds;
      bounds = map.getBounds();
      if (!bounds.contains(latLng)) {
        bounds.extend(latLng);
        return map.fitBounds(bounds);
      }
    };
    ref = ['origin', 'destination'];
    results1 = [];
    for (j = 0, len = ref.length; j < len; j++) {
      key = ref[j];
      state.onChange(key, function(position) {
        if (position != null) {
          return extendMapBoundsToFitPosition(position);
        }
      });
      if (state[key] != null) {
        results1.push(extendMapBoundsToFitPosition(state[key]));
      } else {
        results1.push(void 0);
      }
    }
    return results1;
  };

  syncOriginDestinationMarkers = function(state, map) {
    var j, key, keys, len, markers, movedByUs, sync, syncVisible;
    keys = ['origin', 'destination'];
    markers = {};
    movedByUs = false;
    sync = function(key, position) {
      if (movedByUs) {
        return;
      }
      if (position != null) {
        markers[key].setPosition(position);
        return markers[key].setMap(map);
      } else {
        return markers[key].setMap(null);
      }
    };
    syncVisible = function() {
      var key, marker, results1;
      results1 = [];
      for (key in markers) {
        marker = markers[key];
        if ((state[key] != null) && !state.entireCity) {
          results1.push(marker.setMap(map));
        } else {
          results1.push(marker.setMap(null));
        }
      }
      return results1;
    };
    for (j = 0, len = keys.length; j < len; j++) {
      key = keys[j];
      markers[key] = new google.maps.Marker({
        clickable: false,
        draggable: true,
        flat: true,
        icon: new google.maps.MarkerImage(`icons/marker-${key}.png`),
        title: key === 'origin' && 'Start point' || 'End point'
      });
      google.maps.event.addListener(markers[key], 'dragstart', function() {
        state.freeze('origin');
        state.freeze('destination');
        return state.freeze('routes');
      });
      google.maps.event.addListener(markers[key], 'dragend', function() {
        state.thaw('origin');
        state.thaw('destination');
        return state.thaw('routes');
      });
    }
    google.maps.event.addListener(markers.origin, 'position_changed', function() {
      movedByUs = true;
      state.setOrigin(markers.origin.getPosition());
      return movedByUs = false;
    });
    google.maps.event.addListener(markers.destination, 'position_changed', function() {
      movedByUs = true;
      state.setDestination(markers.destination.getPosition());
      return movedByUs = false;
    });
    state.onChange('origin', function(position) {
      return sync('origin', position);
    });
    state.onChange('destination', function(position) {
      return sync('destination', position);
    });
    state.onChange('entireCity', function(entireCity) {
      return syncVisible();
    });
    sync('origin', state.origin);
    return sync('destination', state.destination);
  };

  showFusionTablesLayer = function(state, map) {
    var fusionTableId, getOptions, layer, refresh, refreshFusionTableId;
    fusionTableId = CITIES[state.city].fusionTableId;
    getOptions = function() {
      return {
        query: {
          select: 'Latitude',
          from: fusionTableId,
          where: `Time >= '${state.minYear}' AND Time < '${state.maxYear + 1}'`
        },
        clickable: state.entireCity
      };
    };
    layer = new google.maps.FusionTablesLayer(getOptions());
    layer.setMap(fusionTableId && state.entireCity && map || null);
    refresh = function() {
      layer.setMap(fusionTableId && state.entireCity && map || null);
      return layer.setOptions(getOptions());
    };
    refreshFusionTableId = function() {
      fusionTableId = CITIES[state.city].fusionTableId;
      return refresh();
    };
    state.onChange('minYear', refresh);
    state.onChange('maxYear', refresh);
    return state.onChange('entireCity', refresh);
  };

  Manager = class Manager {
    constructor(map, state, chartLink, dataLink, worstLocationsDiv) {
      new DataFetcher(state);
      new RouteFinder(state);
      new RouteRenderer(state, map);
      new AccidentFinder(state);
      new AccidentsMarkerRenderer(state, map);
      if (chartLink != null) {
        new TrendChartRenderer(state, chartLink);
      }
      if (dataLink != null) {
        new AccidentsTableRenderer(state, dataLink);
      }
      new WorstLocationsRenderer(state, worstLocationsDiv, map);
      keepMapInStateBounds(map, state);
      syncOriginDestinationMarkers(state, map);
      showFusionTablesLayer(state, map);
    }

  };

  window.Manager = Manager;

  $.fn.address_form = function(originOrDestination, state, map, callback = void 0) {
    var $error, $form, $hint, $input, $status, aPointString, abortClickingOnMap, geocoder, get, getCityBounds, handleGeocoderResult, handleReverseGeocoderResult, lastAddressTyped, lookupLatLng, mapListener, maybeLookupAddress, onTypeAddress, property, set, setByGeocoder, setError, setStatus, setter;
    property = originOrDestination;
    setByGeocoder = false;
    setter = originOrDestination === 'origin' && 'setOrigin' || 'setDestination';
    aPointString = originOrDestination === 'origin' && 'a start point' || 'an end point';
    $form = $(this);
    $hint = $form.find('label.hint');
    $input = $form.find('input[type=text]');
    $error = $form.find('.error');
    $status = $form.find('.status');
    lastAddressTyped = $input.val();
    geocoder = new google.maps.Geocoder();
    mapListener = void 0;
    getCityBounds = function() {
      return CITIES[state.city].bounds;
    };
    get = function() {
      return state[property];
    };
    set = function(value) {
      return state[setter](value);
    };
    setStatus = function(status) {
      $status.text(status || '');
      return (status != null) && $status.show() || $status.hide();
    };
    setError = function(error) {
      $error.text(error || '');
      return (error != null) && $error.show() || $error.hide();
    };
    maybeLookupAddress = function() {
      var addressTyped;
      addressTyped = $input.val();
      if ($.trim(addressTyped || '').length > 0 && addressTyped !== lastAddressTyped) {
        setError(void 0);
        setStatus('Looking up address');
        lastAddressTyped = addressTyped;
        return geocoder.geocode({
          'address': addressTyped,
          'bounds': getCityBounds()
        }, function(results, status) {
          return handleGeocoderResult(results, status);
        });
      }
    };
    handleGeocoderResult = function(results, status) {
      setByGeocoder = true;
      setStatus(void 0);
      if (status === google.maps.GeocoderStatus.ZERO_RESULTS || (status === google.maps.GeocoderStatus.OK && !getCityBounds().contains(results[0].geometry.location))) {
        setError('Not found');
        set(null);
      } else if (status === google.maps.GeocoderStatus.OK) {
        set(results[0].geometry.location);
      } else {
        setError('Failed to look up address');
        set(null);
      }
      if (typeof callback === "function") {
        callback();
      }
      return setByGeocoder = false;
    };
    lookupLatLng = function(latlng) {
      setError(void 0);
      if (latlng != null) {
        lastAddressTyped = '…';
        $input.val(lastAddressTyped);
        setStatus('Looking up address');
        return geocoder.geocode({
          latLng: latlng
        }, function(results, status) {
          return handleReverseGeocoderResult(results, status);
        });
      } else {
        lastAddressTyped = void 0;
        $input.val('');
        return setStatus(void 0);
      }
    };
    handleReverseGeocoderResult = function(results, status) {
      setStatus(void 0);
      if (status === google.maps.GeocoderStatus.OK) {
        lastAddressTyped = results[0].formatted_address;
      } else {
        lastAddressTyped = '(point on map)';
      }
      return $input.val(lastAddressTyped);
    };
    onTypeAddress = function() {
      return maybeLookupAddress();
    };
    $input.on('focus', function() {
      return state.setSelectingOriginOrDestination(originOrDestination);
    });
    $form.on('submit', function(e) {
      e.preventDefault();
      return onTypeAddress() && false;
    });
    $input.on('blur', function() {
      return onTypeAddress() || true;
    });
    abortClickingOnMap = function() {
      if (mapListener == null) {
        return;
      }
      $hint.fadeOut();
      google.maps.event.removeListener(mapListener);
      return mapListener = void 0;
    };
    state.onChange('selectingOriginOrDestination', function(newOriginOrDestination) {
      abortClickingOnMap();
      if (originOrDestination === newOriginOrDestination) {
        $input.focus();
        $hint.fadeIn();
        return mapListener = google.maps.event.addListenerOnce(map, 'click', function(e) {
          var clicking;
          if (mapListener == null) {
            return;
          }
          mapListener = void 0;
          clicking = true;
          set(e.latLng);
          $hint.fadeOut();
          if (typeof callback === "function") {
            callback();
          }
          return true;
        });
      }
    });
    return state.onChange(originOrDestination, function(position) {
      if (setByGeocoder) {
        return;
      }
      return lookupLatLng(position);
    });
  };

  $.fn.mode_form = function(state) {
    // IE doesn't check hidden radios
    $(this).find('label').on('click', function(e) {
      return $(e.target).find('input').attr('checked', 'checked');
    });
    return $.each(this, function() {
      var $form;
      $form = $(this);
      $form.on('click change', function(e) {
        var mode, s;
        s = $form.serialize();
        mode = s.split(/[=]/)[1];
        return state.setMode(mode);
      });
      return state.onChange('mode', function() {
        var $input;
        $input = $form.find(`input[value=${state.mode}]`);
        $form.find('label').removeClass('selected');
        $input.attr('checked', 'checked');
        return $input.closest('label').addClass('selected');
      });
    });
  };

  $.fn.year_range_slider = function(state) {
    var getRange, getSelectedRange, init, updateState, updateText;
    getRange = function() {
      var city;
      city = CITIES[state.city];
      return [city.minYear, city.maxYear];
    };
    getSelectedRange = function() {
      return [state.minYear, state.maxYear];
    };
    init = () => {
      var range;
      range = getRange();
      return $(this).slider({
        min: getRange()[0],
        max: getRange()[1],
        range: true,
        values: getSelectedRange(),
        animate: true
      });
    };
    updateState = () => {
      var maxYear, minYear;
      minYear = $(this).slider('values', 0);
      maxYear = $(this).slider('values', 1);
      state.setMinYear(minYear);
      return state.setMaxYear(maxYear);
    };
    updateText = () => {
      var selectedRange, text;
      selectedRange = getSelectedRange();
      if (selectedRange[0] === selectedRange[1]) {
        text = `${selectedRange[0]}`;
      } else {
        text = `${selectedRange[0]}–${selectedRange[1]}`;
      }
      return $(this).next().text(text);
    };
    state.onChange('minYear', (year) => {
      if (year !== $(this).slider('values', 0)) {
        updateText();
        return $(this).slider('values', 0, year);
      }
    });
    state.onChange('maxYear', (year) => {
      if (year !== $(this).slider('values', 1)) {
        updateText();
        return $(this).slider('values', 1, year);
      }
    });
    $(this).on('slidechange', function() {
      updateState();
      return updateText();
    });
    init();
    return updateText();
  };

}).call(this);
